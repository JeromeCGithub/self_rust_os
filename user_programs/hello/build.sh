#!/usr/bin/env bash
# Build script for the hello user-space program.
#
# This script compiles the Rust no_std binary for the custom x86_64 target
# and converts the resulting ELF to a flat binary using llvm-objcopy.
# It also generates `hello_meta.rs` with layout metadata so the kernel
# can apply per-section page permissions (W^X).
#
# Prerequisites:
#   - Rust nightly toolchain (matching the kernel's rust-toolchain file)
#   - llvm-tools-preview component: rustup component add llvm-tools-preview
#
# Usage:
#   cd user_programs/hello
#   ./build.sh

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

TARGET="x86_64-user-program"
PROFILE="release"
BIN_NAME="hello"
ELF_PATH="target/${TARGET}/${PROFILE}/${BIN_NAME}"
OUTPUT="hello.bin"
META_OUTPUT="hello_meta.rs"

echo "[user_programs/hello] Building ${BIN_NAME} for ${TARGET}..."
cargo build --release

# Locate llvm-objcopy and llvm-readobj from the Rust toolchain.
RUSTC_SYSROOT="$(rustc --print sysroot)"
LLVM_OBJCOPY="$(find "${RUSTC_SYSROOT}" -name 'llvm-objcopy' -type f 2>/dev/null | head -1)"
LLVM_READOBJ="$(find "${RUSTC_SYSROOT}" -name 'llvm-readobj' -type f 2>/dev/null | head -1)"

if [ -z "${LLVM_OBJCOPY}" ]; then
    echo "Error: llvm-objcopy not found in the Rust sysroot."
    echo "Install it with: rustup component add llvm-tools-preview"
    exit 1
fi

if [ -z "${LLVM_READOBJ}" ]; then
    echo "Error: llvm-readobj not found in the Rust sysroot."
    echo "Install it with: rustup component add llvm-tools-preview"
    exit 1
fi

echo "[user_programs/hello] Converting ELF to flat binary..."
"${LLVM_OBJCOPY}" -O binary "${ELF_PATH}" "${OUTPUT}"

SIZE=$(wc -c < "${OUTPUT}")
echo "[user_programs/hello] Built ${OUTPUT} (${SIZE} bytes)"

# ---------------------------------------------------------------------------
# Generate hello_meta.rs with the read-only boundary.
#
# The linker script lays out sections in this order, each ALIGN(4K):
#   .text    (code, read-only + executable)
#   .rodata  (read-only data)
#   .data    (initialized mutable data)
#   .bss     (zero-initialized mutable data)
#
# We compute the read-only size as the offset (from the load base) of the
# first writable section (.data), rounded up to 4 KiB page alignment.
# If .data and .bss are both absent/empty, the entire binary is read-only.
# ---------------------------------------------------------------------------

echo "[user_programs/hello] Generating ${META_OUTPUT}..."

# Extract section headers as JSON-like text and parse the relevant offsets.
# We look for the virtual addresses of .text, .rodata, .data, and .bss to
# determine where the read-only region ends.
#
# The base address (USER_CODE_START) is 0x400000 as defined in linker.ld.
BASE_ADDR=0x400000

# Helper: get the VMA (virtual address) of a section from the ELF.
# Returns empty string if the section does not exist.
get_section_vma() {
    local section_name="$1"
    "${LLVM_READOBJ}" --section-headers "${ELF_PATH}" 2>/dev/null \
        | awk -v name="${section_name}" '
            /Name:/ { current_name = $2 }
            /Address:/ && current_name == name { print $2; exit }
        '
}

# Helper: get the size of a section from the ELF.
get_section_size() {
    local section_name="$1"
    "${LLVM_READOBJ}" --section-headers "${ELF_PATH}" 2>/dev/null \
        | awk -v name="${section_name}" '
            /Name:/ { current_name = $2 }
            /Size:/ && current_name == name { print $2; exit }
        '
}

DATA_VMA=$(get_section_vma ".data")
DATA_SIZE=$(get_section_size ".data")
BSS_VMA=$(get_section_vma ".bss")
BSS_SIZE=$(get_section_size ".bss")
RODATA_VMA=$(get_section_vma ".rodata")
RODATA_SIZE=$(get_section_size ".rodata")
TEXT_VMA=$(get_section_vma ".text")
TEXT_SIZE=$(get_section_size ".text")

# Determine the start of the first writable section.
# If .data exists and has non-zero size, use its VMA.
# Otherwise if .bss exists and has non-zero size, use its VMA.
# Otherwise the entire binary is read-only.
FIRST_WRITABLE_VMA=""

if [ -n "${DATA_VMA}" ] && [ "$(printf '%d' "${DATA_SIZE}")" -gt 0 ]; then
    FIRST_WRITABLE_VMA="${DATA_VMA}"
elif [ -n "${BSS_VMA}" ] && [ "$(printf '%d' "${BSS_SIZE}")" -gt 0 ]; then
    FIRST_WRITABLE_VMA="${BSS_VMA}"
fi

if [ -n "${FIRST_WRITABLE_VMA}" ]; then
    # readonly_size = first_writable_vma - base_addr, already page-aligned
    # because the linker script uses ALIGN(4K).
    READONLY_SIZE=$(printf '%d' $(( $(printf '%d' "${FIRST_WRITABLE_VMA}") - $(printf '%d' "${BASE_ADDR}") )))
else
    # No writable sections — round the entire binary size up to 4K.
    READONLY_SIZE=$(( (SIZE + 4095) / 4096 * 4096 ))
fi

echo "[user_programs/hello] Read-only region: ${READONLY_SIZE} bytes ($(( READONLY_SIZE / 4096 )) pages)"

cat > "${META_OUTPUT}" << EOF
// Auto-generated by \`build.sh\` — do not edit manually.
//
// Contains compile-time metadata about the hello user binary layout so the
// kernel can apply read-only page permissions to the code and rodata pages.

/// Number of bytes from the start of the flat binary that should be mapped
/// as read-only (no \`WRITABLE\` flag). This value is always page-aligned.
///
/// Pages beyond this offset (if any) contain mutable \`.data\`/\`.bss\` sections
/// and are mapped as writable.
pub const READONLY_SIZE: usize = ${READONLY_SIZE};
EOF

echo "[user_programs/hello] Generated ${META_OUTPUT} (READONLY_SIZE = ${READONLY_SIZE})"
